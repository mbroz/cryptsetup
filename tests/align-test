#!/bin/bash

CRYPTSETUP="../src/cryptsetup"
DEV=""
DEV_STACKED="luks0xbabe"
MNT_DIR="./mnt_luks"
PWD1="93R4P4pIqAH8"
PWD2="mymJeD8ivEhE"

cleanup() {
	udevadm settle >/dev/null 2>&1
	if [ -d "$MNT_DIR" ] ; then
	    umount -f $MNT_DIR 2>/dev/null
	    rmdir $MNT_DIR 2>/dev/null
	fi
	[ -b /dev/mapper/$DEV_STACKED ] && dmsetup remove $DEV_STACKED >/dev/null 2>&1
	rmmod scsi_debug 2>/dev/null
	sleep 2
}

fail()
{
	if [ -n "$1" ] ; then echo "FAIL $1" ; else echo "FAIL" ; fi
	cleanup
	exit 100
}

skip()
{
	echo "TEST SKIPPED: $1"
	cleanup
	exit 0
}

add_device() {
	modprobe scsi_debug $@
	if [ $? -ne 0 ] ; then
		echo "This kernel seems to not support proper scsi_debug module, test skipped."
		exit 0
	fi

	sleep 2
	DEV=$(grep -l -e scsi_debug /sys/block/*/device/model | cut -f4 -d /)

	if [ ! -e /sys/block/$DEV/alignment_offset ] ; then
		echo "This kernel seems to not support topology info, test skipped."
		cleanup
		exit 0
	fi

	DEV="/dev/$DEV"
	[ -b $DEV ] || fail "Cannot find $DEV."
}

format() # key_bits expected [forced]
{
	if [ -z "$3" ] ; then
		echo -n "Formatting using topology info ($1 bits key)..."
		echo $PWD1 | $CRYPTSETUP luksFormat $DEV -q -i1 -c aes-cbc-essiv:sha256 -s $1
	else
		echo -n "Formatting using forced sector alignment $3 ($1 bits key)..."
		echo $PWD1 | $CRYPTSETUP luksFormat $DEV -q -i1 -s $1 -c aes-cbc-essiv:sha256 --align-payload=$2
	fi

	ALIGN=$($CRYPTSETUP luksDump $DEV |grep "Payload offset" | sed -e s/.*\\t//)
	#echo "ALIGN = $ALIGN"

	[ -z "$ALIGN" ] && fail
	[ $ALIGN -ne $2 ] && fail "Expected alignment differs: expected $2 != detected $ALIGN"

	# test some operation, just in case
	echo -e "$PWD1\n$PWD2" | $CRYPTSETUP luksAddKey $DEV -i1 --key-slot 1
	[ $? -ne 0 ] && fail "Keyslot add failed."

	$CRYPTSETUP -q luksKillSlot $DEV 1
	[ $? -ne 0 ] && fail "Keyslot removal failed."

	echo "PASSED"
}

get_offsets()
{
	$CRYPTSETUP luksDump $DEV | grep "$1" | cut -s -d ':' -f 2 | sed  -e 's/\s//g' -e :a -e N -e 's/\n/:/g' -e 's/\s//g' -e ta
}

format_null()
{
	if [ $3 -eq 0 ] ; then
		echo -n "Formatting using topology info ($1 bits key) [slot 0"
		echo $PWD1 | $CRYPTSETUP luksFormat $DEV -q -i1 -c null -s $1
	else
		echo -n "Formatting using forced sector alignment $3 ($1 bits key) [slot 0"
		echo $PWD1 | $CRYPTSETUP luksFormat $DEV -q -i1 -c null -s $1 --align-payload=$3
	fi

	POFF=$(get_offsets "Payload offset")
	[ -z "$POFF" ] && fail
	[ $POFF != $2 ] && fail "Expected data offset differs: expected $2 != detected $POFF"
	if [ -n "$4" ] ; then
		for j in 1 2 3 4 5 6 7 ; do
			echo -e "$PWD1\n$PWD2$j" | $CRYPTSETUP luksAddKey $DEV -q -i1 --key-slot $j -c null $PARAMS
			echo -n $j
			[ $? -ne 0 ] && fail
		done

		KOFF=$(get_offsets "Key material offset")
		[ -z "$KOFF" ] && fail
		[ $KOFF != $4 ] && fail "Expected keyslots offsets differ: expected $4 != detected $KOFF"
	fi

	echo "]...PASSED"
}

if [ $(id -u) != 0 ]; then
	echo "WARNING: You must be root to run this test, test skipped."
	exit 0
fi

modprobe --dry-run scsi_debug || exit 0
cleanup

echo "# Create desktop-class 4K drive"
echo "# (logical_block_size=512, physical_block_size=4096, alignment_offset=0)"
add_device dev_size_mb=16 sector_size=512 physblk_exp=3 num_tgts=1
format 256 4096
format 256 2112 8
format 128 2048
format 128 1088 8
format 256 8192 8192
format 128 8192 8192
cleanup

echo "# Create desktop-class 4K drive w/ 63-sector DOS partition compensation"
echo "# (logical_block_size=512, physical_block_size=4096, alignment_offset=3584)"
add_device dev_size_mb=16 sector_size=512 physblk_exp=3 lowest_aligned=7 num_tgts=1
format 256 4103
format 256 2119 8
format 128 2055
format 128 1095 8
cleanup

echo "# Create enterprise-class 4K drive"
echo "# (logical_block_size=4096, physical_block_size=4096, alignment_offset=0)"
add_device dev_size_mb=16 sector_size=4096 num_tgts=1
format 256 4096
format 256 2560 8
format 128 2048
format 128 1536 8
cleanup

echo "# Create classic 512B drive and stack dm-linear"
echo "# (logical_block_size=512, physical_block_size=512, alignment_offset=0)"
add_device dev_size_mb=16 sector_size=512 num_tgts=1
DEV2=$DEV
DEV=/dev/mapper/$DEV_STACKED
dmsetup create $DEV_STACKED --table "0 32768 linear $DEV2 0"
format 256 4096
format 256 2112 8
format 128 2048
format 128 1088 8
format 128 8192 8192
cleanup

echo "# Offset check: 512B sector drive"
add_device dev_size_mb=16 sector_size=512 num_tgts=1
#           |k| expO reqO expected slot offsets
format_null  64 2048    0 8:72:136:200:264:328:392:456
format_null  64  520    1
format_null  64  520    8
format_null  64  640  128
format_null  64 2048 2048
format_null 128 2048    0 8:136:264:392:520:648:776:904
format_null 128 1032    1
format_null 128 1032    8
format_null 128 1152  128
format_null 128 2048 2048
format_null 256 4096    0 8:264:520:776:1032:1288:1544:1800
format_null 256 2056    1
format_null 256 2056    8
format_null 256 2176  128
format_null 256 4096 2048
format_null 512 4096    0 8:512:1016:1520:2024:2528:3032:3536
format_null 512 4040    1
format_null 512 4040    8
format_null 512 4096  128
format_null 512 4096 2048
cleanup

echo "# Offset check: 4096B sector drive"
add_device dev_size_mb=16 sector_size=4096 num_tgts=1
format_null  64 2048    0 8:72:136:200:264:328:392:456
format_null  64  520    1
format_null  64  520    8
format_null  64  640  128
format_null  64 2048 2048
format_null 128 2048    0 8:136:264:392:520:648:776:904
format_null 128 1032    1
format_null 128 1032    8
format_null 128 1152  128
format_null 128 2048 2048
format_null 256 4096    0 8:264:520:776:1032:1288:1544:1800
format_null 256 2056    1
format_null 256 2056    8
format_null 256 2176  128
format_null 256 4096 2048
format_null 512 4096    0 8:512:1016:1520:2024:2528:3032:3536
format_null 512 4040    1
format_null 512 4040    8
format_null 512 4096  128
format_null 512 4096 2048
cleanup

echo "# Create enterprise-class 4K drive with fs and LUKS images."
# loop device here presents 512 block but images have 4k block
# cryptsetup should properly use 4k block on direct-io
add_device dev_size_mb=16 sector_size=4096 physblk_exp=0 num_tgts=1
for file in $(ls img_fs_*.img.bz2) ; do
    echo "Format using fs image $file."
    bzip2 -d -c $file | dd of=$DEV bs=1M 2>/dev/null || fail "bad image"
    [ ! -d $MNT_DIR ] && mkdir $MNT_DIR
    mount $DEV $MNT_DIR || skip "Mounting image is not available."
    echo $PWD1 | $CRYPTSETUP luksFormat -i 1 $MNT_DIR/luks.img || fail
    echo $PWD2 | $CRYPTSETUP luksFormat -i 1 $MNT_DIR/luks.img --header $MNT_DIR/luks_header.img || fail
    umount $MNT_DIR
done
cleanup
